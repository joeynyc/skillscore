import * as fs from 'fs-extra';
import * as path from 'path';
import { SkillScore, CategoryScore, Reporter } from '../scorer';

function readVersion(): string {
  try {
    return JSON.parse(fs.readFileSync(path.join(__dirname, '..', '..', 'package.json'), 'utf-8')).version;
  } catch {
    return '0.0.0';
  }
}

const VERSION = readVersion();

export class MarkdownReporter implements Reporter {
  generateReport(score: SkillScore): string {
    const lines: string[] = [];
    
    // Header
    lines.push('# ğŸ“Š SkillScore Evaluation Report');
    lines.push('');
    
    // Skill Info
    lines.push('## ğŸ“‹ Skill Information');
    lines.push('');
    lines.push(`**Name:** ${score.skill.name}`);
    lines.push(`**Path:** \`${score.skill.skillPath}\``);
    if (score.skill.description) {
      lines.push(`**Description:** ${score.skill.description}`);
    }
    lines.push(`**Files:** ${score.skill.structure.totalFiles} files`);
    lines.push(`**SKILL.md:** ${score.skill.structure.hasSkillMd ? 'âœ… Present' : 'âŒ Missing'}`);
    lines.push('');
    
    // Overall Score
    lines.push('## ğŸ¯ Overall Score');
    lines.push('');
    const gradeEmoji = this.getGradeEmoji(score.letterGrade);
    lines.push(`### ${gradeEmoji} Grade: ${score.letterGrade}`);
    lines.push('');
    lines.push(`**Score:** ${score.percentage.toFixed(1)}% (${score.totalScore.toFixed(1)}/${score.maxTotalScore.toFixed(1)} points)`);
    lines.push('');
    
    // Progress bar
    const progressBar = this.createMarkdownProgressBar(score.percentage);
    lines.push(progressBar);
    lines.push('');
    
    // Category Breakdown
    lines.push('## ğŸ“ Category Breakdown');
    lines.push('');
    
    // Summary table
    lines.push('| Category | Score | Percentage | Weight | Weighted Score |');
    lines.push('|----------|-------|------------|--------|----------------|');
    
    for (const cat of score.categoryScores) {
      const emoji = this.getScoreEmoji(cat.percentage);
      lines.push(`| ${emoji} ${cat.category.name} | ${cat.score}/${cat.maxScore} | ${cat.percentage.toFixed(1)}% | ${(cat.category.weight * 100).toFixed(0)}% | ${cat.weightedScore.toFixed(2)} |`);
    }
    lines.push('');
    
    // Detailed category analysis
    for (const cat of score.categoryScores) {
      lines.push(this.formatCategoryDetails(cat));
      lines.push('');
    }
    
    // Summary and Recommendations
    lines.push('## ğŸ“ˆ Summary & Recommendations');
    lines.push('');
    
    const strengths = score.categoryScores
      .filter(cat => cat.percentage >= 80)
      .map(cat => cat.category.name);
    
    const needsImprovement = score.categoryScores
      .filter(cat => cat.percentage < 60)
      .map(cat => cat.category.name);
    
    const moderate = score.categoryScores
      .filter(cat => cat.percentage >= 60 && cat.percentage < 80)
      .map(cat => cat.category.name);
    
    if (strengths.length > 0) {
      lines.push('### âœ… Strengths');
      lines.push('');
      for (const strength of strengths) {
        lines.push(`- ${strength}`);
      }
      lines.push('');
    }
    
    if (moderate.length > 0) {
      lines.push('### ğŸ”„ Good but Could Improve');
      lines.push('');
      for (const mod of moderate) {
        lines.push(`- ${mod}`);
      }
      lines.push('');
    }
    
    if (needsImprovement.length > 0) {
      lines.push('### âŒ Needs Improvement');
      lines.push('');
      for (const weakness of needsImprovement) {
        lines.push(`- ${weakness}`);
      }
      lines.push('');
    }
    
    // Action Items
    lines.push('### ğŸ¯ Action Items');
    lines.push('');
    
    const failedFindings = score.categoryScores
      .flatMap(cat => cat.findings.filter(f => f.type === 'fail'))
      .slice(0, 5);
    
    if (failedFindings.length > 0) {
      lines.push('Priority fixes:');
      lines.push('');
      for (const finding of failedFindings) {
        lines.push(`1. ${finding.message}`);
      }
    } else {
      lines.push('ğŸ‰ No critical issues found! Consider the improvement suggestions above.');
    }
    
    lines.push('');
    
    // Footer
    lines.push('---');
    lines.push('');
    lines.push(`*Generated by SkillScore v${VERSION} on ${score.timestamp.toLocaleString()}*`);
    lines.push('');
    
    return lines.join('\n');
  }
  
  private formatCategoryDetails(cat: CategoryScore): string {
    const lines: string[] = [];
    const emoji = this.getScoreEmoji(cat.percentage);
    
    lines.push(`### ${emoji} ${cat.category.name} (${cat.percentage.toFixed(1)}%)`);
    lines.push('');
    lines.push(`**Weight:** ${(cat.category.weight * 100).toFixed(0)}% | **Score:** ${cat.score}/${cat.maxScore} | **Weighted Score:** ${cat.weightedScore.toFixed(2)}`);
    lines.push('');
    lines.push(`*${cat.category.description}*`);
    lines.push('');
    
    if (cat.findings.length > 0) {
      lines.push('**Findings:**');
      lines.push('');
      
      const groupedFindings = {
        pass: cat.findings.filter(f => f.type === 'pass'),
        fail: cat.findings.filter(f => f.type === 'fail'),
        warning: cat.findings.filter(f => f.type === 'warning'),
        info: cat.findings.filter(f => f.type === 'info')
      };
      
      if (groupedFindings.pass.length > 0) {
        lines.push('âœ… **Passed:**');
        for (const finding of groupedFindings.pass) {
          lines.push(`- ${finding.message} (+${finding.points} points)`);
        }
        lines.push('');
      }
      
      if (groupedFindings.fail.length > 0) {
        lines.push('âŒ **Failed:**');
        for (const finding of groupedFindings.fail) {
          lines.push(`- ${finding.message}`);
        }
        lines.push('');
      }
      
      if (groupedFindings.warning.length > 0) {
        lines.push('âš ï¸ **Warnings:**');
        for (const finding of groupedFindings.warning) {
          lines.push(`- ${finding.message}${finding.points > 0 ? ` (+${finding.points} points)` : ''}`);
        }
        lines.push('');
      }
      
      if (groupedFindings.info.length > 0) {
        lines.push('â„¹ï¸ **Info:**');
        for (const finding of groupedFindings.info) {
          lines.push(`- ${finding.message}`);
        }
        lines.push('');
      }
    }
    
    return lines.join('\n');
  }
  
  private getScoreEmoji(percentage: number): string {
    if (percentage >= 90) return 'ğŸŸ¢';
    if (percentage >= 80) return 'ğŸ”µ';
    if (percentage >= 70) return 'ğŸŸ¡';
    if (percentage >= 60) return 'ğŸŸ ';
    return 'ğŸ”´';
  }
  
  private getGradeEmoji(grade: string): string {
    if (grade.startsWith('A')) return 'ğŸ†';
    if (grade.startsWith('B')) return 'ğŸ¥‰';
    if (grade.startsWith('C')) return 'ğŸŸ¨';
    if (grade.startsWith('D')) return 'ğŸŸ§';
    return 'ğŸŸ¥';
  }
  
  private createMarkdownProgressBar(percentage: number): string {
    const width = 20;
    const filled = Math.round((percentage / 100) * width);
    const empty = width - filled;
    
    const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
    return `\`${bar}\` ${percentage.toFixed(1)}%`;
  }
}